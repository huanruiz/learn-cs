# 3_Bits_Bytes_and_Integers-II
紧接上一节课的内容, 我们先尝试一下位运算. 首先是**unsigned的加法运算**. 如果超出了范围, 最高位会被直接丢弃.
```
 1101
+0101
10010
```

而对于**two's complement的加法**, 如果是负数加正数, 实际上就实现了相减的效果. 单计算结果超出范围时, 结果也会错误, 因为最高位是符号位, 所以可能会造成计算结果正负号的改变.
```
 1101  -3
+0101   5
10010  -2

 1011  -5
+0011   3
 1010  -2
```

对于**乘法计算**, 和加法的道理是一样的, 因为计算的结果可能会超过限制的范围, 导致值出现奇怪的数字. 用**two's complement的乘法**举例.
```
 0100  5
*0100  5
11001 -7 (最高位被丢弃)
```

对于乘法计算, 如果是乘或除以$2^{n}$, 可以用左右位移来计算, 这样就可以一次运算得到结果, 而不是让加法器不断循环地去加每个数字. 当然现代机器不仅仅有加法器, 乘法并不是一直让加法去循环处理, 但是位移这种计算方式显然是更快的. 提到位移, 我们要清楚两个概念: arithmetic shift和logical shift. 前者考虑符号位, 也就是如果对于signed整型进行右移, 最高位补的数字会与符号位相同, 0则补0, 1则补1. 而后者不考虑符号位. 

对于移位还有一个现象. 考虑signed整型右移时的情况, 若原数字是`1101`, 也就是十进制的-3, 我们将它右移一位, 得到`1110`, 也就是十进制的-2. 而如果是正数`0101`的右移一位是`0010`, 也就是从5变成了2, 相当于在除以2之后进行了向下取整. 为了使正负数的计逻辑一致, 在执行负数位移时, 机器会加上一个bias number. 也就是`1101`变成了`1110`, 在进行向右位移, 得到`1111`, 也就是十进制的-1, 这样就和正数的向下取整逻辑一致了. 

## 参考
1. [Intro to Computer Systems: Schedule for Fall 2015](http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html)
2. [lab](http://csapp.cs.cmu.edu/3e/labs.html)